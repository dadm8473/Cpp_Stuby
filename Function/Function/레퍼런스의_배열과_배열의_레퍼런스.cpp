//// 레퍼런스의 배열?
//int a, b;
//int& arr[2] = { a, b };
//// 레퍼런스의 배열은 불법이다.
//// C++ 규정에서 레퍼런스의 배열을
//// 선언 하는 것을 막고있다.
//// 레퍼런스의 포인터는 존재할 수 없다.
//// 레퍼런스는 메모리 상에 특정 공간을
//// 차지하는 것이 아니라
//// 컴파일 시에 원레 레퍼런스가 참조하던 변수의
//// 주소값으로 대체된다.
//// 따라서 메모리 공간을 차지하지 않는 것의
//// 포인터를 생ㄱ가한다는 것은 말이 안된다.

//#include <iostream>
//
//int main() {
//	int arr[3] = { 1,2,3 };
//	int(&ref)[3] = arr;
//	// ref가 arr를 가리키도록 했다.
//	// ref[0] 부터 ref[2] 까지 각각 arr[0] 부터 arr[2]의 레퍼런스가 됬다.
//	// 배열의 레퍼런스는 배열의 크기를 정확히 맞추어야한다.
//	// 배열 크기가 3이라면 반드시 크기가 3인 레퍼런스를 만들어야한다.
//	// 이러한 이유로 잘 사용되지 않는다.
//
//	//int arr[3][2] = { 1,2,3,4,5,6 };
//	//int(&ref)[3][2] = arr;
//	//// 이차원 배열도 이렇게 선언할 수 있다.
//
//
//	ref[0] = 2;
//	ref[1] = 3;
//	ref[2] = 1;
//
//	std::cout << arr[0] << arr[1] << arr[2] << std::endl;
//
//	return 0;
//}